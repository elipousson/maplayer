% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/layer_count.R
\name{layer_count}
\alias{layer_count}
\title{Layer for counting occurrences of data in spatial relation a location or other
sf object}
\usage{
layer_count(
  data,
  location = NULL,
  y = NULL,
  join = sf::st_intersects,
  largest = TRUE,
  replace_na = FALSE,
  lims = NULL,
  .id = "id",
  grid_params = list(alpha = 1, color = NA),
  show_data = FALSE,
  data_params = list(mapping = aes(), alpha = 0.75, size = 1),
  show_label = FALSE,
  label_params = NULL,
  scale_fn = ggplot2::scale_fill_continuous,
  scale_params = list(type = "viridis", breaks = scales::breaks_pretty(n = 4)),
  ...
)
}
\arguments{
\item{data}{Data to count in relationship to y}

\item{location}{Passed to x parameter of \code{\link[sfext:count_sf_ext]{sfext::count_sf_ext()}}.}

\item{y}{If \code{NULL} (default), y defaults to an \code{sf} object created by
\code{\link[sfext:st_make_grid_ext]{st_make_grid_ext()}} using x or data (if x is \code{NULL}) as the x parameter
for \code{\link[sfext:st_make_grid_ext]{st_make_grid_ext()}}. If not \code{NULL}, y must be an \code{sf} object that has
a column with the same name as .id (defaults to "id").}

\item{join}{geometry predicate function with the same profile as \link[sf]{st_intersects}; see details}

\item{largest}{logical; if \code{TRUE}, return \code{x} features augmented with the fields of \code{y} that have the largest overlap with each of the features of \code{x}; see https://github.com/r-spatial/sf/issues/578}

\item{replace_na}{If \code{TRUE}, replace NA values from count with 0.}

\item{lims}{Optional numeric vector with minimum or both minimum and
maximum count values. If provided, any values below the minimum are set to
that minimum and any values above the maximum as set to the maximum. If
only one value is provided, it is assumed to be a minimum limit.}

\item{.id}{A name to use for the cell id column. Defaults to "id".}

\item{grid_params}{Passed to \code{\link[=layer_location_data]{layer_location_data()}} to style foreground grid
with fill based on count.}

\item{show_data}{If \code{TRUE}, add background layer with data to stack returned
by function. If \code{TRUE} and grid_params includes a fixed aesthetic for
alpha, divide alpha in half to ensure background data is visible below the
filled grid.}

\item{data_params}{Passed to \code{\link[=layer_location_data]{layer_location_data()}} to style background
layer based on data.}

\item{show_label}{If \code{TRUE}, add layer with labels to stack returned by
function.}

\item{label_params}{Passed to \code{\link[=layer_labelled]{layer_labelled()}} for foreground labels with
fill based on count.}

\item{scale_fn, scale_params}{Scale function and parameters. Defaults to
\code{\link[ggplot2:scale_colour_continuous]{ggplot2::scale_fill_continuous()}}.}

\item{...}{
  Arguments passed on to \code{\link[sfext:count_sf_ext]{sfext::count_sf_ext}}
  \describe{
    \item{\code{wt}}{<\code{\link[dplyr:dplyr_data_masking]{data-masking}}> Frequency weights.
Can be \code{NULL} or a variable:
\itemize{
\item If \code{NULL} (the default), counts the number of rows in each group.
\item If a variable, computes \code{sum(wt)} for each group.
}}
    \item{\code{sort}}{If \code{TRUE}, will show the largest groups at the top.}
    \item{\code{keep_na}}{If \code{TRUE}, filter NA values from count. Ignored if replace_na
is \code{TRUE}.}
    \item{\code{geometry}}{If \code{TRUE} (default) return a \code{sf} object. If \code{FALSE}, return
a data frame.}
    \item{\code{name}}{The name of the new column in the output.

If omitted, it will default to \code{n}. If there's already a column called \code{n},
it will error, and require you to specify the name.}
  }}
}
\description{
Wraps \code{\link[sfext:count_sf_ext]{sfext::count_sf_ext()}}. Specification of parameters for this function
may be too complex and may be changed in the future.
}
\examples{

nc <- sf::st_read(system.file("shape/nc.shp", package = "sf"))
data <- sf::st_sample(nc, 75)

ggplot() +
  layer_count(data = data, location = nc)

ggplot() +
  layer_count(data = data, y = nc, .id = "FIPS")

}
